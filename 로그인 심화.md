서버에 평문(plain text) 비밀번호를 저장하면 절대 안 되고, 대신 해시(단방향 암호화) 해서 저장하고 로그인할 때는 입력한 평문 비밀번호를 해시와 비교해야 합니다. Spring 생태계에서는 BCrypt가 표준적으로 널리 쓰입니다. 아래에 안전하고 실무적인 방법을 정리해드릴게요: 설정, 코드 예시(회원가입/로그인), DB 타입, 마이그레이션/운영 팁까지 모두 포함합니다.

1) 개념 요약 — 핵심 원칙

비밀번호는 단방향 해시(예: BCrypt) 로 저장. 복호화 불가.

로그인: 클라이언트가 보낸 평문 비밀번호를 서버에서 해시화된 값과 비교(match).

반드시 HTTPS 사용: 네트워크 전송 중 탈취 방지.

BCrypt는 내부적으로 salt(랜덤값)를 자동 추가 → 같은 비밀번호도 매번 다른 해시가 됨.

2) 의존성 (Spring Boot 사용 시)

Spring Security를 쓰면 BCryptPasswordEncoder를 바로 사용 가능:

<!-- pom.xml -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>


(만약 Spring Security 전체를 도입하기 싫으면 spring-security-crypto만 추가 가능.)

3) Bean 설정 (PasswordEncoder)
@Configuration
public class SecurityConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // 기본 strength 10 (원한다면 new BCryptPasswordEncoder(12))
    }
}

4) 회원가입 로직 — 비밀번호 해시해서 저장

예: service에서 저장하기 전에 인코딩

@Service
public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    public MemberServiceImpl(MemberRepository memberRepository, PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public void signup(MemberDto dto) {
        String rawPwd = dto.getPwd();
        String encodedPwd = passwordEncoder.encode(rawPwd);

        Member member = new Member();
        member.setId(dto.getId());
        member.setPwd(encodedPwd);   // ← 평문이 아닌 해시 저장
        member.setName(dto.getName());
        member.setEmail(dto.getEmail());
        // ... 기타 필드

        memberRepository.save(member); // JPA, JdbcTemplate 등 사용
    }
}


DB 컬럼은 충분한 길이 필요 (VARCHAR(60) 이상 — BCrypt는 보통 60자).

5) 로그인 로직 — 입력 비밀번호와 해시 비교
@Override
public boolean login(String id, String rawPwd) {
    Member member = memberRepository.findById(id);
    if (member == null) return false; // 아이디 없음

    String storedEncodedPwd = member.getPwd();
    boolean matches = passwordEncoder.matches(rawPwd, storedEncodedPwd);
    return matches; // true이면 로그인 성공
}


passwordEncoder.matches(raw, encoded) 가 내부적으로 salt를 사용해 비교합니다.

절대 평문 비교( rawPwd.equals(stored) ) 하지 마세요.

6) JdbcTemplate 예시 (현재 코드 스타일에 맞춘 예)

회원 조회:

public Member findById(String id) {
    String sql = "SELECT id, pwd, name, email FROM member WHERE id = ?";
    try {
        return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
            Member m = new Member();
            m.setId(rs.getString("id"));
            m.setPwd(rs.getString("pwd"));
            m.setName(rs.getString("name"));
            m.setEmail(rs.getString("email"));
            return m;
        }, id);
    } catch (EmptyResultDataAccessException e) {
        return null;
    }
}


로그인:

public boolean login(Member memberInput) {
    Member stored = memberRepository.findById(memberInput.getId());
    if (stored == null) return false;
    return passwordEncoder.matches(memberInput.getPwd(), stored.getPwd());
}

7) DB 스키마 주의

pwd 컬럼 타입: VARCHAR(60) 이상 권장 (BCrypt는 일반적으로 60자).

ALTER TABLE member MODIFY COLUMN pwd VARCHAR(100) NOT NULL;

8) 기존 사용자(이미 평문 저장된 경우) 마이그레이션 전략

안전한 방법: 회원 가입 및 비밀번호 변경 시점에만 해시 저장. 기존 사용자의 평문이 DB에 있으면 로그인 시 평문인지 해시인지 판별 후:

로그인 시 DB 값이 평문으로 들어있다면 passwordEncoder.encode(raw)와 비교하지 말고 raw.equals(stored)로 확인(임시).

로그인 성공 시 새 해시로 업데이트: update member set pwd = :encoded where id = :id.

또는 DB 전체를 강제 초기화(사용자에게 비밀번호 리셋 안내) — UX/보안 정책에 따라 선택.

권장: 가능한 한 빨리 모든 비밀번호를 해시로 바꾸세요.

9) 추가 보안 권장사항 (실무)

HTTPS 필수.

로그인 시 브루트포스 방지(레이트 리밋, 캡차, 계정 잠금).

비밀번호 정책(최소 길이, 복잡도) + 비밀번호 유효기간(조심해서 적용).

비밀번호 재설정 토큰은 랜덤, 짧은 만료 시간, 한 번만 사용.

민감 정보(비밀번호 제외)도 필요하면 암호화 고려.

감사 로그 기록(다만 비밀번호는 절대 로그에 남기지 마세요).

로그인 성공/실패 기록 및 모니터링.

10) 테스트 권장 절차

회원가입 -> DB에 pwd가 평문이 아닌 $2a$... 형식으로 저장되는지 확인.

로그인: 올바른 비밀번호로 로그인 성공, 틀리면 실패.

기존 사용자 마이그레이션(있다면) 동작 확인.

요약 (한 문장)

회원가입 시 PasswordEncoder#encode(raw)로 비밀번호 해시를 저장하고, 로그인 시 PasswordEncoder#matches(raw, storedHash)로 비교하세요. Spring의 BCryptPasswordEncoder를 사용하면 salt 자동 처리와 안전한 비교가 보장됩니다.



백엔드가 JdbcTemplate 스타일이었으니 그에 맞춰 간단하고 실무적인 코드(컨트롤러 → 서비스 → 레포지토리) 와 프론트 axios 예제까지 모두 포함합니다.

전제: Gradle 기반 Spring Boot 백엔드, React 프론트가 frontend/에 따로 존재.
또한 Spring Security 라이브러리를 추가하되, 기본 시큐리티 설정(로그인 폼 등)은 비활성화하고 PasswordEncoder 빈만 사용합니다.

1) build.gradle (백엔드)

spring-boot-starter-security 하나면 BCryptPasswordEncoder를 쓸 수 있습니다.

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security' // PasswordEncoder 포함
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'mysql:mysql-connector-java'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}


참고: spring-boot-starter-security를 추가하면 Spring Boot가 기본적으로 모든 경로를 보호합니다. 아래 SecurityConfig에서 API 허용 설정을 해줍니다.

2) DB 스키마 (pwd 컬럼 길이 확보)

BCrypt 해시는 보통 ~60자 입니다. 안전하게 100자로 만드세요:

ALTER TABLE member MODIFY COLUMN pwd VARCHAR(100) NOT NULL;

3) Spring: SecurityConfig — PasswordEncoder 빈과 기본 시큐리티 설정
@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(); // strength 기본 10
    }

    // Spring Security 3.x+ 방식: 인증/인가 기본을 끄고 특정 endpoint 허용
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // API 사용시 필요에 따라 설정
            .authorizeHttpRequests()
                .requestMatchers("/api/signup", "/api/login", "/api/**public/**").permitAll()
                .anyRequest().authenticated()
            .and()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); // 토큰 기반이면
        return http.build();
    }
}

4) 엔티티 / DTO / 레포지토리 (JdbcTemplate 스타일)
Member.java (간단 DTO / 엔티티)
public class Member {
    private String id;
    private String pwd; // 저장되는 값은 해시 문자열
    private String name;
    private String email;
    // getters / setters (Lombok 사용시 @Data)
}

MemberRepository.java (인터페이스)
public interface MemberRepository {
    void save(Member member);
    Member findById(String id);
}

MemberRepositoryImpl.java (JdbcTemplate 사용)
@Repository
public class MemberRepositoryImpl implements MemberRepository {
    private final JdbcTemplate jdbcTemplate;

    public MemberRepositoryImpl(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public void save(Member member) {
        String sql = "INSERT INTO member (id, pwd, name, email, mdate) VALUES (?, ?, ?, ?, now())";
        jdbcTemplate.update(sql, member.getId(), member.getPwd(), member.getName(), member.getEmail());
    }

    @Override
    public Member findById(String id) {
        String sql = "SELECT id, pwd, name, email FROM member WHERE id = ?";
        try {
            return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
                Member m = new Member();
                m.setId(rs.getString("id"));
                m.setPwd(rs.getString("pwd"));
                m.setName(rs.getString("name"));
                m.setEmail(rs.getString("email"));
                return m;
            }, id);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }
}

5) 서비스 레이어 — signup(암호화) / login(비교, 마이그레이션 지원)
@Service
public class MemberService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    public MemberService(MemberRepository memberRepository, PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    // 회원가입: 평문 비밀번호를 받아서 해시화 후 저장
    public void signup(Member dto) {
        String raw = dto.getPwd();
        String encoded = passwordEncoder.encode(raw);
        dto.setPwd(encoded);
        memberRepository.save(dto);
    }

    // 로그인: 입력한 평문(rawPwd)과 DB에 저장된 hashedPwd 비교
    // 또한, 기존에 평문으로 저장된 레거시 사용자에 대해 자동 마이그레이션(로그인 성공 시 해시로 교체) 가능
    public boolean login(String id, String rawPwd) {
        Member stored = memberRepository.findById(id);
        if (stored == null) return false;

        String storedPwd = stored.getPwd();
        // 1) 일반적: storedPwd이 BCrypt 해시인지 확인 (BCrypt 해시는 보통 "$2a$" 또는 "$2b$"로 시작)
        if (storedPwd != null && (storedPwd.startsWith("$2a$") || storedPwd.startsWith("$2b$") || storedPwd.startsWith("$2y$"))) {
            return passwordEncoder.matches(rawPwd, storedPwd);
        } else {
            // 2) 레거시: DB에 평문(또는 다른 포맷)으로 저장되어 있다면 (임시)
            if (storedPwd.equals(rawPwd)) {
                // 로그인 성공 -> 비밀번호를 해시로 바꿔서 저장(마이그레이션)
                String newHash = passwordEncoder.encode(rawPwd);
                // 업데이트 SQL (간단 구현 — repo에 update 메서드 추가하거나 save로 대체)
                updatePwd(id, newHash);
                return true;
            } else {
                return false;
            }
        }
    }

    private void updatePwd(String id, String newHash) {
        String sql = "UPDATE member SET pwd = ? WHERE id = ?";
        // 직접 JdbcTemplate 사용 (repository에 위임하는 게 깔끔)
        if (memberRepository instanceof MemberRepositoryImpl) {
            ((MemberRepositoryImpl) memberRepository).getJdbcTemplate().update(sql, newHash, id);
        } else {
            // 또는 repository에 updatePassword 메서드 추가 권장
        }
    }
}


권장: MemberRepository에 updatePassword(String id, String newHash) 메서드를 추가해서 처리하는 게 더 깔끔합니다. 위 코드는 예시입니다.

6) 컨트롤러 (API 엔드포인트 예)
@RestController
@RequestMapping("/api")
public class MemberController {
    private final MemberService memberService;

    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody Member dto) {
        // 추가로 아이디 중복 체크 등 필요
        memberService.signup(dto);
        return ResponseEntity.ok().body("signup OK");
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody Map<String,String> body) {
        String id = body.get("id");
        String pwd = body.get("pwd");
        boolean ok = memberService.login(id, pwd);
        if (ok) {
            // 로그인 성공 시 JWT 토큰 발급 등 처리 가능
            return ResponseEntity.ok(Map.of("success", true));
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("success", false));
        }
    }
}

7) React 프론트: 회원가입 / 로그인 예제 (axios 사용)
signup
// frontend/src/api/auth.js
import axios from "axios";

export const signup = async (payload) => {
  // payload = { id, pwd, name, email }
  const res = await axios.post("/api/signup", payload); // 프록시 설정 또는 절대 URL 사용
  return res.data;
}

login
import axios from "axios";

export const login = async (payload) => {
  // payload = { id, pwd }
  try {
    const res = await axios.post("/api/login", payload);
    return res.data; // { success: true } 등
  } catch (err) {
    if (err.response && err.response.status === 401) {
      return { success: false };
    }
    throw err;
  }
}


개발 시 React dev server에서 /api로 프록시를 걸어두면 localhost:3000에서 localhost:8080으로 편하게 호출할 수 있습니다. package.json에:

"proxy": "http://localhost:8080"

8) 추가 권장/운영 팁 (요약)

HTTPS(TLS) 사용: 로그인/회원가입 등 민감 데이터를 항상 HTTPS로 전송하세요.

비밀번호 제한 정책: 최소 길이(8~12), 복잡도 권장(하지만 UX 고려).

로그인 실패 제한: 브루트포스 방지(계정 잠금 / 레이트 리밋 / CAPTCHA 등).

비밀번호 재설정: 토큰 기반, 만료 시간 짧게, 한 번만 사용.

비밀번호는 절대 로그에 남기지 않음.

레거시 평문 사용자 마이그레이션: 로그인 시 해시로 갱신(안전한 방법).

9) 마이그레이션(기존 평문 사용자) 권장 패턴 — 요약 코드

로그인 시 DB 값이 해시인지 확인하고( startsWith("$2") ), 아니면 평문 비교 후 해시로 업데이트.